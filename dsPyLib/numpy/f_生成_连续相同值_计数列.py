# -*- coding:utf-8 -*-
__author__ = 'Dragon Sun'
__date__ = '2025-06-10 08:22:04'

import numpy


def 生成_连续相同值_计数列(值序列: numpy.ndarray) -> numpy.ndarray:
    """
    高性能实现连续相同值计数（纯NumPy）
    例如：
        值序列 = [3, 3, 3, 4, 6, 6, 6, 6]
        计数列 = [1, 2, 3, 1, 1, 2, 3, 4]
    @param 值序列: 输入的值序列
    @return: 连续相同值的计数序列(从1开始)
    """

    序列长度 = len(值序列)  # 8
    if 序列长度 == 0:
        return numpy.array([], dtype=int)

    # 1. 创建变化点数组
    变化点序列 = numpy.ones(序列长度, dtype=bool)  # 创建一个与值序列等长全为1的数组(也就是都是True) [True, True, True， True, True， True, True, True]
    变化点序列[1:] = (值序列[1:] != 值序列[:-1])  # 从第二个元素开始(第一个始终认为是变化点) [True, False, False,  True,  True, False, False, False])

    # 2. 生成每个分组编号
    分组编号序列 = 变化点序列.cumsum()  # 分组编号从1开始 计算数组沿指定轴的累积和 [1, 1, 1, 2, 3, 3, 3, 3]

    # 3. 生成每个分组的起始索引（避免使用numpy.where）
    分组起始索引序列 = numpy.nonzero(变化点序列)[0]  # 返回非0元素索引，返回的是一个元祖(行,列)，取行所以[0]  [0, 3, 4]

    # 4. 将 分组编号 映射到 分组起始索引（避免numpy.repeat）
    #       ①. 分组编号序列 - 1：将分组编号转换为数组索引
    #           [1, 1, 1, 2, 3, 3, 3, 3] → [1-1, 1-1, 1-1, 2-1, 3-1, 3-1, 3-1, 3-1] = [0, 0, 0, 1, 2, 2, 2, 2]
    #       ②. 分组起始索引序列[分组编号序列 - 1] →
    #               分组起始索引序列[[0, 0, 0, 1, 2, 2, 2, 2]] =
    #                   [分组起始索引序列[0],  # 0 → 0
    #                    分组起始索引序列[0],  # 0 → 0
    #                    分组起始索引序列[0],  # 0 → 0
    #                    分组起始索引序列[1],  # 1 → 3
    #                    分组起始索引序列[2],  # 2 → 4
    #                    分组起始索引序列[2],  # 2 → 4
    #                    分组起始索引序列[2],  # 2 → 4
    #                    分组起始索引序列[2]]  # 2 → 4
    #               = [0, 0, 0, 3, 4, 4, 4, 4]  # 每一个元素所在分组的起始索引
    元素分组起始索引 = 分组起始索引序列[分组编号序列 - 1]

    # 5. 计算连续计数 numpy.arange()生成等差数列，与range()函数类似
    连续计数序列 = numpy.arange(序列长度) - 元素分组起始索引 + 1

    return 连续计数序列
